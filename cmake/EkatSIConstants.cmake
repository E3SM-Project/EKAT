#----------------
#
# CMake will use the contents of this to auto-generate physical constants
#  for both C++ and Fortran.
#
#----------------


function(gen_consts_file cxx_header precision output_file)
  set(parse_start FALSE)
  set(is_fortran FALSE)
  string(FIND ${output_file} ".F90" pos_upperf)
  string(FIND ${output_file} ".f90" pos_lowerf)
  if (pos_lowerf GREATER_EQUAL 0 OR pos_upperf GREATER_EQUAL 0)
    set(is_fortran TRUE)
  endif()

  # c++ boilerplate
  list(APPEND cxx_lines "/* This file was generated by CMake and ${cxx_header}")
  list(APPEND cxx_lines "* using cmake/EkatSIConstants.cmake ")
  list(APPEND cxx_lines "*")
  list(APPEND cxx_lines "*        DO NOT EDIT ")
  list(APPEND cxx_lines "*/")
  list(APPEND cxx_lines "#include \"ekat/physics/constants.hpp\"")
  list(APPEND cxx_lines "namespace ekat {")
  list(APPEND cxx_lines "namespace physics {")

  # fortran boilerplate
  list(APPEND fortran_lines "! This file was generated by CMake and ${cxx_header}")
  list(APPEND fortran_lines "! using cmake/EkatSIConstants.cmake")
  list(APPEND fortran_lines "!")
  list(APPEND fortran_lines "!    DO NOT EDIT ")
  list(APPEND fortran_lines "!")
  list(APPEND fortran_lines "module ekat_physical_constants")
  list(APPEND fortran_lines "  use iso_c_binding, only: c_int, c_double, c_float")
  list(APPEND fortran_lines "  implicit none")
  list(APPEND fortran_lines "  public")
  if (${precision} MATCHES "double")
    list(APPEND fortran_lines "  integer, parameter :: c_real = c_double")
  else()
    list(APPEND fortran_lines "  integer, parameter :: c_real = c_float")
  endif()

  # parse file into list of strings with newlines removed
  file(STRINGS ${cxx_header} lines)
  foreach(line ${lines})
    if (parse_start)
      # are we done?
      string(FIND ${line} "EKAT_CONSTANTS_END_PARSE" pos)
      if (pos GREATER_EQUAL 0)
        list(APPEND fortran_lines "end module")
        list(APPEND cxx_lines "// ETI")
        list(APPEND cxx_lines "template struct Constants<float>_SEMICOLON_")
        list(APPEND cxx_lines "template struct Constants<double>_SEMICOLON_")
        list(APPEND cxx_lines "} // namespace physics")
        list(APPEND cxx_lines "} // namespace ekat")
        break()
      endif()

      # look for the new constant flag
      string(FIND ${line} "///" pos)
      if (pos GREATER_EQUAL 0)
        # retrieve the comment
        math(EXPR begin "${pos} + 3")
        string(SUBSTRING ${line} ${begin} -1 comment)
      else()
      # not a new constant; is it an assignment?
        string(FIND ${line} "=" equals)
        if (equals GREATER_EQUAL 0)
          # this is a constant; we need its name and value

          # get the name: everything before the = sign, spaces stripped
          math(EXPR end "${equals} - 1")
          string(SUBSTRING ${line} 0 ${end} name)
          string(STRIP ${name} name)
          string(FIND ${name} " " last_space REVERSE)
          math(EXPR begin "${last_space} + 1")
          string(SUBSTRING ${name} ${begin} -1 name)

          # get the value: everything numeric between = and ;, spaces stripped
          math(EXPR begin "${equals} + 1")
          string(SUBSTRING ${line} ${begin} -1 value)
          string(REPLACE ";" "" value ${value})
          string(STRIP ${value} value)

          # check if we've retrieved a number
          set(is_numeric FALSE)
          if (value MATCHES "^([0-9]*)(\\.[0-9]*)?([eE][+\\-]?[0-9]+)?$")
            set(is_numeric TRUE)
          endif()
          list(APPEND fortran_lines "  ! ${comment}")
          if (is_numeric)
            list(APPEND fortran_lines "  real(c_real), parameter :: ${name} = ${value}_c_real")
          else()
            list(APPEND fortran_lines "  real(c_real), parameter :: ${name} = ${value}")
          endif()
          list(APPEND cxx_lines "  template <typename Scalar>\n  Scalar constexpr Constants<Scalar>::${name}_SEMICOLON_")
          unset(comment)
          unset(name)
          unset(value)
          unset(equals)
          unset(begin)
          unset(end)
        endif()
      endif()
    else()
      string(FIND ${line} "EKAT_CONSTANTS_START_PARSE" pos)
      if (pos GREATER_EQUAL 0)
        set(parse_start TRUE)
      endif()
    endif()
  endforeach()

  message(STATUS "  writing physical constants to file ${output_file}")
  if (is_fortran)
    # write the fortran file
    string(REPLACE ";" "\n" fortran_source "${fortran_lines}")
    file(WRITE ${output_file} ${fortran_source})
  else()
    # write the cpp file
    string(REPLACE ";" "\n" cpp_source "${cxx_lines}")
    string(REPLACE "_SEMICOLON_" "\;" cpp_source "${cpp_source}")
    file(WRITE ${output_file} ${cpp_source})
  endif()
endfunction()

gen_consts_file(${CONSTS_HEADER} ${CONSTS_PRECISION} ${CONSTS_OUTPUT_FILE})
