#!/usr/bin/env python3

import argparse, pathlib, os, sys, subprocess

###############################################################################
def expect(condition, error_msg, exc_type=SystemExit, error_prefix="ERROR:"):
###############################################################################
    """
    Similar to assert except doesn't generate an ugly stacktrace. Useful for
    checking user error, not programming error.

    >>> expect(True, "error1")
    >>> expect(False, "error2")
    Traceback (most recent call last):
        ...
    SystemExit: ERROR: error2
    """
    if not condition:
        msg = error_prefix + " " + error_msg
        raise exc_type(msg)

###############################################################################
def run_cmd(cmd, input_str=None, from_dir=None, verbose=None, dry_run=False,
            arg_stdout=subprocess.PIPE, arg_stderr=subprocess.PIPE, env=None, combine_output=False):
###############################################################################
    """
    Wrapper around subprocess to make it much more convenient to run shell commands

    >>> run_cmd('ls file_i_hope_doesnt_exist')[0] != 0
    True
    """
    arg_stderr = subprocess.STDOUT if combine_output else arg_stderr
    from_dir = str(from_dir) if from_dir else from_dir

    if verbose:
        print("RUN: {}\nFROM: {}".format(cmd, os.getcwd() if from_dir is None else from_dir))

    if dry_run:
        return 0, "", ""

    if input_str is not None:
        stdin = subprocess.PIPE
        input_str = input_str.encode('utf-8')
    else:
        stdin = None

    proc = subprocess.Popen(cmd,
                            shell=True,
                            stdout=arg_stdout,
                            stderr=arg_stderr,
                            stdin=stdin,
                            cwd=from_dir,
                            env=env)

    output, errput = proc.communicate(input_str)
    if output is not None:
        try:
            output = output.decode('utf-8', errors='ignore')
            output = output.strip()
        except AttributeError:
            print("Something funcky for output")
            pass
    if errput is not None:
        try:
            errput = errput.decode('utf-8', errors='ignore')
            errput = errput.strip()
        except AttributeError:
            print("Something funcky for errput")
            pass

    stat = proc.wait()

    return stat, output, errput


###############################################################################
def parse_command_line(args, description):
###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} <executable>
OR
{0} --help

\033[1mEXAMPLES:\033[0m
    \033[1;32m# Lightweight python wrapper for a test that handles thread binding.\033[0m
    > {0} ./my_exec

""".format(pathlib.Path(args[0]).name),
        description=description,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument("-e","--executable", help="The name of the executable to run",required=True)
    #  parser.add_argument("exec_args",nargs=argparse.REMAINDER,help="Additional args to fwd to the executable")

    return parser.parse_known_args(args[1:])

###############################################################################
def run_test(executable,exec_args):
###############################################################################

    print("execname: {}".format(executable))

    omp_env = []
    omp_env.append("OMP_DISPLAY_ENV=verbose")
    omp_env.append("OMP_DISPLAY_AFFINITY=true")
    omp_env.append("OMP_PROC_BIND=spread")
    omp_env.append("OMP_PLACES=threads")

    env = os.environ

    # Check if we're run with MPI
    if "OMPI_COMM_WORLD_SIZE" in env:
        nranks = int(env["OMPI_COMM_WORLD_SIZE"])
        myrank = int(env["OMPI_COMM_WORLD_RANK"])
    else:
        nranks = 1
        myrank = 0

    # Start with empty cmd, and append to it
    cmd = ""

    # If run with --resource-spec-file, we will have some special env var set
    if "CTEST_RESOURCE_GROUP_COUNT" in env:
        # Total number of resources for this test (for all ranks/threads)
        res_count = int(env["CTEST_RESOURCE_GROUP_COUNT"])
        my_res_id = myrank % res_count

        # Get the list of devices ids in my resource group
        key = "CTEST_RESOURCE_GROUP_" + str(my_res_id)
        expect(key in env, "Error! CTEST_RESOURCE_GROUP_COUNT found in the env, but can't find {}".format(key))
        my_res_name = env[key]
        expect (my_res_name=="devices", "Error! My ctest resource group should be 'devices'.")
        key += "_DEVICES"
        expect(key in env, "Error! CTEST_RESOURCE_GROUP_{} found in the env, but can't find {}".format(my_res_id,key))
        my_res_str = env[key];

        # Split the CTEST_RESOURCE_GROUP_[N]_DEVICE string into tokens, and get the slots ids
        my_res = my_res_str.split(';')
        ids = []
        for res in my_res:
            id_slots_tokens = res.split(',')
            id_tokens = id_slots_tokens[0].split(':')
            ids.append(id_tokens[1])

        # Now get the chunk of ids that belongs to this rank
        expect (len(ids) % nranks == 0, "Error! Number of ranks does not divide the number of resources.")
        ids_per_rank = int(len(ids) / nranks)
        my_ids = ids[myrank*ids_per_rank : (myrank+1)*ids_per_rank]
        ids_str = "{" + "},{".join(my_ids) + "}"

        #  omp_env.append("OMP_NUM_THREADS={}".format(len(my_ids)))
        cmd = "taskset -c " + ",".join(my_ids)

        # This file is to be run through cmake's configure_file, which will expand the
        # variable TEST_LAUNCHER_ON_GPU to either True or False
        if ${TEST_LAUNCHER_ON_GPU}:
            expect (len(my_ids)==1, "Error! For GPU runs, each rank should use only one device.")
            exec_args.append(" --kokkos-device-id={}".format(ids[0]))

    cmd += " {}".format(executable)
    cmd += " {}".format(" ".join(exec_args))

    stat, out, _ = run_cmd (cmd,verbose=True,combine_output=True,env=env)
    print (out)

    return stat==0

###############################################################################
def _main_func(description):
###############################################################################
    options, rest = parse_command_line(sys.argv, description)
    success = run_test(**vars(options), exec_args=rest)

    sys.exit(0 if success else 1)

###############################################################################

if (__name__ == "__main__"):
    _main_func(__doc__)
