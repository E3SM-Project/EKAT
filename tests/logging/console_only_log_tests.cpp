#include <catch2/catch.hpp>

#include "ekat/logging/ekat_logger.hpp"
#include "ekat/mpi/ekat_comm.hpp"

#include <experimental/filesystem>

TEST_CASE("console_only", "[logging]") {
  namespace filesystem = std::experimental::filesystem;

  using namespace ekat;
  using namespace ekat::logger;

  Comm comm(MPI_COMM_WORLD);
  std::string log_name = "console_only";

  // We cannot be sure when loggers flush to file. The only sure thing
  // is that when they go out of scope (or anyway get destroyed)
  // the flushing is completed. So wrap Loggers in a scope
  SECTION("all_ranks")
  {
    {
      // Exploit LogAllRanks to decorate message with ".$size.$rank".
      std::string msg = LogAllRanks::get_log_name("all_ranks",comm);


      Logger<LogNoFile,LogAllRanks> mylog("all_ranks_console_only", LogLevel::debug, comm);
      mylog.set_no_format();
      mylog.warn(msg);
    }

    // Verify no file was generated by inspecting all content of cwd,
    // and verifying none of them contains $log_name
    auto cwd = filesystem::current_path();
    for (const auto& entry : cwd) {
      auto name = entry.string();
      REQUIRE (name.find("all_ranks_console_only")==std::string::npos);
    }
  }

  SECTION("root_rank") {
    {
      // Exploit LogAllRanks to decorate message with ".$size.$rank".
      std::string msg = LogAllRanks::get_log_name("root_rank",comm);

      Logger<LogNoFile,LogRootRank> mylog("root_rank_console_only", LogLevel::debug, comm);
      mylog.set_no_format();
      mylog.warn(msg);
    }

    // Verify no file was generated by inspecting all content of cwd,
    // and verifying none of them contains $log_name
    auto cwd = filesystem::current_path();
    for (const auto& entry : cwd) {
      auto name = entry.string();
      REQUIRE (name.find("root_rank_console_only")==std::string::npos);
    }
  }
}
