#include <catch2/catch.hpp>

#include "ekat/logging/ekat_logger.hpp"
#include "ekat/mpi/ekat_comm.hpp"

#if defined(HAS_EXP_FILESYSTEM)
#include <experimental/filesystem>
namespace filesystem = std::experimental::filesystem;
#elif defined(HAS_FILESYSTEM)
#include <filesystem>
namespace filesystem = std::filesystem;
#else
#error "Niether HAS_EXP_FILESYSTEM nor HAS_FILESYSTEM was defined!"
#endif

// When multiple copies of the test are run (one per MPI_COMM_WORLD size),
// we need to make sure each test uses different names for the log files,
// even if the Logger does not append comm rank/size information.
std::string add_comm_size (const std::string& s, const ekat::Comm& comm) {
  return s + std::to_string(comm.size());
}

TEST_CASE("console_only", "[logging]") {

  using namespace ekat;
  using namespace ekat::logger;

  Comm comm(MPI_COMM_WORLD);
  std::string log_name = "console_only";

  // We cannot be sure when loggers flush to file. The only sure thing
  // is that when they go out of scope (or anyway get destroyed)
  // the flushing is completed. So wrap Loggers in a scope
  SECTION("all_ranks")
  {
    {
      // Exploit LogAllRanks to decorate message with ".$size.$rank".
      std::string msg = LogAllRanks::get_log_name("all_ranks",comm);


      Logger<LogNoFile,LogAllRanks> mylog("all_ranks_console_only", LogLevel::debug, comm);
      mylog.set_no_format();
      mylog.warn(msg);
    }

    // Verify no file was generated by inspecting all content of cwd,
    // and verifying none of them contains $log_name
    auto cwd = filesystem::current_path();
    for (const auto& entry : cwd) {
      auto name = entry.string();
      REQUIRE (name.find("all_ranks_console_only")==std::string::npos);
    }
  }

  SECTION("root_rank") {
    {
      // Exploit LogAllRanks to decorate message with ".$size.$rank".
      std::string msg = LogAllRanks::get_log_name("root_rank",comm);

      Logger<LogNoFile,LogRootRank> mylog("root_rank_console_only", LogLevel::debug, comm);
      mylog.set_no_format();
      mylog.warn(msg);
    }

    // Verify no file was generated by inspecting all content of cwd,
    // and verifying none of them contains $log_name
    auto cwd = filesystem::current_path();
    for (const auto& entry : cwd) {
      auto name = entry.string();
      REQUIRE (name.find("root_rank_console_only")==std::string::npos);
    }
  }
}
